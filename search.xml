<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>从零开始，使用Hexo搭建个人博客~</title>
    <url>/Build_hexo_blog_tutorial.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="从零开始，使用Hexo搭建个人博客"><a href="#从零开始，使用Hexo搭建个人博客" class="headerlink" title="从零开始，使用Hexo搭建个人博客~"></a>从零开始，使用Hexo搭建个人博客~</h1><blockquote>
<p>参考文章：<a href="https://blog.fiveth.cc/p/bb32/">https://blog.fiveth.cc/p/bb32/</a></p>
</blockquote>
<h2 id="准备环境及工具"><a href="#准备环境及工具" class="headerlink" title="准备环境及工具"></a>准备环境及工具</h2><p>1、node.js 环境</p>
<blockquote>
<p>node.js下载链接：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p>
</blockquote>
<p>2、git环境</p>
<blockquote>
<p>git下载链接：<a href="https://git-scm.com/install/">https://git-scm.com/install/</a></p>
</blockquote>
<p>验证是否下载成功，打开cmd终端，依次输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v（这个是node附带的）</span><br><span class="line">git -v</span><br></pre></td></tr></table></figure>

<p>显示版本号证明安装成功</p>
<p>3、Github 账号</p>
<p>需要新建一个Github仓库</p>
<p><strong>仓库名严格按照以下格式创建</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">用户名.github.io</span><br></pre></td></tr></table></figure>

<p>将仓库设置为可公开访问 Public</p>
<p>添加README</p>
<p>最后创建</p>
<p>在Github中添加SSH Key 以方便部署博客</p>
<p>进入任意文件夹，右键空白处然后点Git bash here,输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;邮件地址&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后敲4次Enter</p>
<p>然后进入C:\Users\用户名，在里面进入.ssh文件</p>
<p>用记事本打开里面的id_rsa.pub,全选复制里面的代码</p>
<p><strong>然后打开github</strong></p>
<p>进入用户设置，找到SSH keys</p>
<p>新建SSH keys，名称随意，在下面粘贴代码，</p>
<p>然后创建</p>
<p><strong>测试是否成功</strong></p>
<p>在git bash中输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>回车，然后再输入yes</p>
<p>4、Typora</p>
<blockquote>
<p>Typora下载链接：<a href="https://typoraio.cn/">https://typoraio.cn/</a></p>
<p>可以在网上下载破解版或者在官网中下载beta版本</p>
</blockquote>
<h2 id="本地使用"><a href="#本地使用" class="headerlink" title="本地使用"></a>本地使用</h2><p>使用npm工具下载hexo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>在本地新建一个文件夹blog，放置相关博客文件</p>
<p>在blog中右键进入git bash，准备初始化hexo</p>
<p>依次执行下面的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo初始化</span></span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line"><span class="comment"># hexo包下载</span></span><br><span class="line">hexo install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成浏览器静态文件内容</span></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地启动hexo服务器</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>浏览器输入localhost:4000 进入生成的hexo本地服务器（在命令行使用ctrl + c 关闭）</p>
<h2 id="将本地博客内容部署到Github"><a href="#将本地博客内容部署到Github" class="headerlink" title="将本地博客内容部署到Github"></a>将本地博客内容部署到Github</h2><p>在本地下载并安装hexo之后会生成的目录结构如下图</p>
<p><img src="/Build_hexo_blog_tutorial/01.png" alt="hexo文件夹内容"></p>
<p>编辑博客配置文件_config.yml，将博客内容链接到Github中</p>
<p>使用文本编辑器打开_config.yml，拉到最下面将deploy后面的全删掉，复制粘贴以下内容</p>
<p>repository后面为你的Github仓库链接，ssh或者https都行</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repository:</span> <span class="string">git@github.com:&lt;your</span> <span class="string">Github</span> <span class="string">name&gt;/&lt;your</span> <span class="string">Github</span> <span class="string">name&gt;.github.io.git</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意缩进格式：每行前面都有两个空格不要删，每个冒号后面都有个空格也不要删！</p>
</blockquote>
<p>保存退出</p>
<p>回到blog文件夹，进入git bash 安装自动部署发布工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>在git bash中依次输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo静态文件生成</span></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="comment"># hexo本地文件部署到Github</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>



<blockquote>
<p>如果是第一次使用git的话会需要配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;git config --global user.email <span class="string">&quot;你的邮箱&quot;</span></span><br><span class="line">&gt;git config --global user.name <span class="string">&quot;你的名字&quot;</span></span><br></pre></td></tr></table></figure>

<p>配置完后再<code>hexo d</code>上传</p>
<p>在跳出来的窗口内进行登录</p>
</blockquote>
<p>到此，已经成功将hexo本地内容部署到Github中，并且可以在任意电脑进行访问</p>
<p>访问链接：<your Github name>.github.io</p>
<h2 id="网站基础配置"><a href="#网站基础配置" class="headerlink" title="网站基础配置"></a>网站基础配置</h2><p>上面的步骤执行完成之后，整个hexo博客都是初始默认的</p>
<p>现在进行一些基础配置</p>
<p>打开_config.yml文件</p>
<p>将#Site下面按自己的需求填上</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">描述</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">关键词</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">站主</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">语言（可以填写zh-CN）</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">时区（可以填写Asia/Shanghai）</span></span><br></pre></td></tr></table></figure>



<p>保存退出</p>
<blockquote>
<p>注意：每次修改完配置或者添加文章等，要使其生效，都要执行以下命令</p>
</blockquote>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;# 将<span class="built_in">source</span>文件夹下的文件生成静态html文件</span><br><span class="line">&gt;hexo g</span><br><span class="line"></span><br><span class="line">&gt;# 启动本地hexo服务器，已修改的文件在本地生效</span><br><span class="line">&gt;hexo s</span><br><span class="line"></span><br><span class="line">&gt;# 将hexo本地内容部署到Github中（将修改的内容进行同步）</span><br><span class="line">&gt;hexo d</span><br></pre></td></tr></table></figure></blockquote>
<h2 id="上传文章"><a href="#上传文章" class="headerlink" title="上传文章"></a>上传文章</h2><p>在blog文件夹中打开git bash, 输入下方代码就可以生成新的文章md文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new 文章标题</span><br></pre></td></tr></table></figure>

<p>可简写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n 文章标题</span><br></pre></td></tr></table></figure>

<p>文章是.md格式，自动生成在我们的blog文件夹中的source&#x2F;_posts中</p>
<p>推荐用Typora软件来编辑.md格式的文件</p>
<p>写好以后仍需打开git bash进行生成、上传</p>
<p>关于写文章时插入图片的问题</p>
<blockquote>
<p>参考文章链接：<a href="https://blog.csdn.net/2301_77285173/article/details/130189857">https://blog.csdn.net/2301_77285173/article/details/130189857</a></p>
</blockquote>
<p>建议为每个文章建立单独的资源文件夹，然后将图片资源放到该文件夹中</p>
<p>注意，设置的文章封面图片不能放在该文件夹中，因为在front-matter中引用该文件夹下的资源无效</p>
<p>对每篇文章建立一个资源文件夹，需要修改_config.yml配置文件如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<p>修改完成后，在终端新建文章时，会自动生成一个和文章同名的资源文件夹，如下图所示</p>
<p><img src="/Build_hexo_blog_tutorial/02.png" alt="文章及其资源文件夹"></p>
<blockquote>
<p>注意：如果文章名称有空格，需要使用双引号引起来</p>
</blockquote>
<p>对于在Typora中插入图片不显示的问题</p>
<p>安装以下插件，可以使typora在预览时正常显示图片</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure>



<h2 id="配置个性化主题"><a href="#配置个性化主题" class="headerlink" title="配置个性化主题"></a>配置个性化主题</h2><blockquote>
<p>参考文章：<a href="https://butterfly.js.org/posts/21cfbf15/">https://butterfly.js.org/posts/21cfbf15/</a></p>
</blockquote>
<p>执行完以上步骤，我们还可以下载个性化的主题对整体博客进行美化~</p>
<p>我主要使用的是butterfly主题，主要是简洁明了~</p>
<p>butterfly主题的安装方式有两种：使用git安装或者使用npm安装</p>
<p>从你的blog根目录进入终端</p>
<p>git安装命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure>

<p>npm安装命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-butterfly</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议使用git方式进行安装，因为博主在使用npm方式安装后，主题好像有点小bug，部分配置没有生效</p>
</blockquote>
<p>应用主题</p>
<p>修改blog目录下的_config.yml文件，把主题修改问butterfly</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure>



<p>安装插件</p>
<p>如果沒有 pug 以及 stylus 的渲染器，需要执行以下命令安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>



<p>建议：</p>
<p>在 hexo 的根目录创建一个文件 _config.butterfly.yml，并把主题目录的 _config.yml 內容复制到 _config.butterfly.yml 去。</p>
<p><img src="/Build_hexo_blog_tutorial/03.png"></p>
<blockquote>
<p>使用git命令安装的主题保存在themes文件夹中，使用npm命令安装的主题保存在node_modules文件夹中</p>
</blockquote>
<p>注意:</p>
<p>复制的是主题的 _config.yml ，而不是 hexo 的 _config.yml</p>
<p>不要把主题目录的 _config.yml 删掉</p>
<p>以后只需要在 _config.butterfly.yml 进行配置就行。如果使用了 _config.butterfly.yml， 配置主题的 _config.yml 将不会有效果。</p>
<p>Hexo 会自动合并主题中的 _config.yml 和 _config.butterfly.yml 里的配置，如果存在同名配置，会使用 _config.butterfly.yml 的配置，其优先度较高。</p>
<p>设置导航菜单</p>
<p> 打开_config.butterfly.yml文件，在对应位置添加以下内容</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">Home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">Archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="attr">Tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">Categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">List||fas</span> <span class="string">fa-list||hide:</span></span><br><span class="line">   <span class="attr">Music:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">   <span class="attr">Movie:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line">  <span class="attr">Link:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="attr">About:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br></pre></td></tr></table></figure>

<p>每一个菜单项都需要在资源文件夹中进行创建才能使用，除了Home、Archives</p>
<p>下面以标签页和分类页为例</p>
<p>标签页：</p>
<p>在blog文件夹中打开git bash，输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>在source文件夹中找到 source&#x2F;tags&#x2F;index.md 此文件，进行修改：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-01-05 00:00:00</span><br><span class="line">type: &#x27;tags&#x27;</span><br><span class="line">orderby: random</span><br><span class="line"><span class="section">order: 1</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>分类页</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>在source文件夹中找到 source&#x2F;categories&#x2F;index.md 此文件，进行修改：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2018-01-05 00:00:00</span><br><span class="line"><span class="section">type: &#x27;categories&#x27;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>创建友链：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="built_in">link</span></span><br></pre></td></tr></table></figure>

<p>在source文件夹中找到 source&#x2F;link&#x2F;index.md 此文件，进行修改：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 友情链接</span><br><span class="line">date: 2018-06-07 22:17:49</span><br><span class="line"><span class="section">type: &#x27;link&#x27;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>友链数据来源：</p>
<p>在 blog 根目录中的 source&#x2F;_data（如果没有 _data 文件夹，请自行创建），创建一个文件 link.yml</p>
<p>本地生成</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">class_name:</span> <span class="string">友情链接</span></span><br><span class="line">  <span class="attr">class_desc:</span> <span class="string">那些人，那些事</span></span><br><span class="line">  <span class="attr">link_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hexo</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://hexo.io/zh-tw/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">快速、简单且强大的网志框架</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">class_name:</span> <span class="string">网站</span></span><br><span class="line">  <span class="attr">class_desc:</span> <span class="string">值得推荐的网站</span></span><br><span class="line">  <span class="attr">link_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Youtube</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://www.youtube.com/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">视频网站</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Weibo</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://www.weibo.com/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">中国最大社交分享平台</span></span><br></pre></td></tr></table></figure>

<p>远程拉取：从 4.0.0 开始，支持从远程加载友情链接，远程拉取只支持 json。</p>
<p>注意： 选择远程加载后，本地生成的方法会无效。</p>
<p>在 source&#x2F;link&#x2F;index.md 这个文件的 front-matter 添加远程链接</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;class_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;友情链接&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;class_desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;那些人，那些事&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;link_list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hexo&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://hexo.io/zh-tw/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;avatar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;descr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;快速、简单且强大的网志框架&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;class_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;网站&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;class_desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值得推荐的网站&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;link_list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Youtube&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://www.youtube.com/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;avatar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;descr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;视频网站&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Weibo&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://www.weibo.com/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;avatar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;descr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中国最大社交分享平台&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Twitter&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://twitter.com/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;avatar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;descr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;社交分享平台&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>主题支持友情链接随机排序，只需要在顶部 front-matter 添加 random: true</p>
</blockquote>
<p>其他图片相关的butterfly主题配置参考链接：<a href="https://butterfly.js.org/posts/4aa8abbe/">https://butterfly.js.org/posts/4aa8abbe/</a></p>
<p>关于评论区、图库等相关的配置会在后续更新~~~ </p>
<p>待续~~~</p>
<h2 id="配置Front-matter"><a href="#配置Front-matter" class="headerlink" title="配置Front-matter"></a>配置Front-matter</h2><blockquote>
<p>参开文章链接：<a href="https://butterfly.js.org/posts/dc584b87/">https://butterfly.js.org/posts/dc584b87/</a></p>
</blockquote>
<p>Front-matter 是 markdown 文件最上方以 — 分隔的区域，用于指定个别档案的变数。</p>
<p>Page Front-matter 用于 页面 配置<br>Post Front-matter 用于 文章页 配置</p>
<p>1、Page Front-matter</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aside:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line">random:</span><br><span class="line">limit:</span><br><span class="line">  type:</span><br><span class="line"><span class="section">  value:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p><img src="/Build_hexo_blog_tutorial/04.png" alt="Page Front-matter参数详解"></p>
<p>2、Post Front-matter</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">comments:</span></span><br><span class="line"><span class="emphasis">cover:</span></span><br><span class="line"><span class="emphasis">toc:</span></span><br><span class="line"><span class="emphasis">toc_</span>number:</span><br><span class="line">toc<span class="emphasis">_style_</span>simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright<span class="emphasis">_author:</span></span><br><span class="line"><span class="emphasis">copyright_</span>author<span class="emphasis">_href:</span></span><br><span class="line"><span class="emphasis">copyright_</span>url:</span><br><span class="line">copyright<span class="emphasis">_info:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line">aside:</span><br><span class="line">abcjs:</span><br><span class="line"><span class="section">noticeOutdate:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p><img src="/Build_hexo_blog_tutorial/05.png" alt="Post Front-matter参数详解"></p>
<h2 id="配置自定义域名访问"><a href="#配置自定义域名访问" class="headerlink" title="配置自定义域名访问"></a>配置自定义域名访问</h2><p>首先需要有一个自定义域名，在阿里云或者腾讯云使用CNAME方式进行域名解析</p>
<p>登录Github，进入连接hexo博客内容的仓库（用户名.github.io）</p>
<p>Settings——&gt;Pages——&gt;Custom domain</p>
<p>在Custom domain下面的方框中填入自定义域名，点击Save保存</p>
<p>勾选Enforce HTTPS</p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="Typora中打不出中文标点符号"><a href="#Typora中打不出中文标点符号" class="headerlink" title="Typora中打不出中文标点符号"></a>Typora中打不出中文标点符号</h2><p>快捷键ctrl + . 进行切换</p>
<h2 id="页面渲染失败问题"><a href="#页面渲染失败问题" class="headerlink" title="页面渲染失败问题"></a>页面渲染失败问题</h2><p>hexo在本地生成的静态文件可以在本地正常加载及访问，但是使用hexo d 命令部署到Github之后，可以通过xxx.github.io进行访问，但是浏览器中css页面渲染失败。</p>
<blockquote>
<p>参考解决文章链接：<a href="https://blog.csdn.net/m0_60930579/article/details/126312041">https://blog.csdn.net/m0_60930579/article/details/126312041</a></p>
</blockquote>
<p>在_config.yml中修改url链接</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://xuduyinuo.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure>



<h2 id="hexo文章添加多个标签"><a href="#hexo文章添加多个标签" class="headerlink" title="hexo文章添加多个标签"></a>hexo文章添加多个标签</h2><p>在文章的front-matter部分按照如下格式填写tags部分</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 如何在Hexo中添加多个标签</span><br><span class="line">date: 2023-01-01</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">  -</span> Hexo</span><br><span class="line"><span class="section">  - 博客</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>



<h2 id="文章结尾的中文标题乱码问题"><a href="#文章结尾的中文标题乱码问题" class="headerlink" title="文章结尾的中文标题乱码问题"></a>文章结尾的中文标题乱码问题</h2><p>当使用 hexo n title 命令新建文章时，如果title是中文标题，则在文章结尾的文章链接中会出现中文乱码问题，如下</p>
<p><img src="/Build_hexo_blog_tutorial/07.png" alt="中文标题文章连接乱码"></p>
<p>解决方案：</p>
<p>在使用hexo n title 命令新建文章时，title使用英文</p>
<p><img src="/Build_hexo_blog_tutorial/06.png" alt="测试英文标题文章链接不乱码"></p>
<p>然后进入生成的文章的md页面，修改post front-matter部分中title为中文标题</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 测试文章标题</span><br><span class="line">date: 2025-01-01</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">  -</span> Hexo</span><br><span class="line"><span class="section">  - 博客</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>这样在封面中显示的标题为front-matter中的中文标题，文章结尾中的文章链接中的链接为使用 hexo n title 命令生成的英文标题链接了~</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>Graph-constrained Reasoning:Faithful Reasoning on Knowledge Graphs with  Large Language Models</title>
    <url>/GCR.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h1><p>paper link: <a href="https://icml.cc/virtual/2025/poster/45868">https://icml.cc/virtual/2025/poster/45868</a></p>
<p>Code and data are available at: <a href="https://github.com/RManLuo/graph-constrained-reasoning">https://github.com/RManLuo/graph-constrained-reasoning</a></p>
<h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><ol>
<li>LLM由于幻觉问题和缺乏特定领域的知识，推理的可靠性不足。</li>
<li>现有的KG增强LLM的方法（基于检索和基于代理的方法），难以准确的从KG中检索知识。</li>
</ol>
<h1 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h1><ol>
<li>提出GCR框架</li>
<li>结合微调的”小“模型的图推理能力和通用大模型的归纳推理能力增强框架的推理性能</li>
<li>在RoG-webqsp和RoG-cwq等五个数据集上进行实验，证明了GCR实现了零幻觉且在当时达到了SOTA。（在无需训练的情况下，在零样本提示中具有广泛的通用性）</li>
</ol>
<h1 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h1><h2 id="Graph-constrained-Reasoning-GCR"><a href="#Graph-constrained-Reasoning-GCR" class="headerlink" title="Graph-constrained Reasoning (GCR)"></a>Graph-constrained Reasoning (GCR)</h2><p>将KGs直接引入LLMs的解码过程，实现可靠推理。</p>
<p>由三个主要部分组成：1）知识图Trie构造 2）图约束解码 3）图归纳推理</p>
<p>GCR的总体框架如下图（c）所示：</p>
<p><img src="/GCR/GCR%E6%A1%86%E6%9E%B6%E5%9B%BE.png" alt="GCR框架图"></p>
<h2 id="Knowledge-Graph-Trie-Construction"><a href="#Knowledge-Graph-Trie-Construction" class="headerlink" title="Knowledge Graph Trie Construction"></a>Knowledge Graph Trie Construction</h2><p>因为知识图谱结构化的特性，LLM难以有效进行推理。</p>
<p>作者提出将KG的结构化知识转化为KG-Trie（知识图谱前缀树）索引，来应用于LLM的解码过程，促进LLM的推理能力。</p>
<p>方法：给定一个KG和问题及主题实体。</p>
<ol>
<li>从主题实体开始，使用图遍历算法在KG中遍历固定跳数的推理路径</li>
<li>将搜索到的推理路径转化为自然语言句子</li>
<li>使用LLM的分词器工具将自然语言句子转换为token并存储在KG-Trie中</li>
</ol>
<p>形式化为如下公式：</p>
<p><img src="/GCR/build_KG_trie.png" alt="build_KG_trie"></p>
<h2 id="Graph-constrained-Decoding"><a href="#Graph-constrained-Decoding" class="headerlink" title="Graph-constrained Decoding"></a>Graph-constrained Decoding</h2><p>给定一个问题Q，通过提示一个经过微调之后的轻量化的小模型，在LLM解码时使用上一步骤中得到的KG-Trie作约束，保证LLM生成的推理路径都是KG中存在的有效的真实的路径。</p>
<p>LLM每次通过图约束解码得到有效的推理路径之后再切换回常规解码，生成以路径为条件的假设答案。</p>
<p><img src="/GCR/Graph-constrained-Decoding.png"></p>
<p>微调轻量化小模型方法：</p>
<p>训练数据中包含问题、问题实体、答案实体和问题相关知识图谱三元组</p>
<p>先将知识图谱三元组转化为图结构，再使用最短路径算法连接问题实体和答案实体，使其连接的路径作为该问题的推理路径。</p>
<p>作者实验标明，使用微调的轻量化小模型也能得到良好的推理性能。</p>
<blockquote>
<p>图约束解码方法不同于基于检索的解码方法，它将预先构造的KG-Trie集成到LLMs的解码过程中。这不仅减少了输入token，而且弥补了LLMs中的非结构化推理和KGs中的结构化知识之间的差距，允许在KGs上进行有效的推理，而不管其规模大小，这将导致可靠的推理，从而得到答案。</p>
</blockquote>
<h2 id="Graph-Inductive-Reasoning"><a href="#Graph-Inductive-Reasoning" class="headerlink" title="Graph Inductive Reasoning"></a>Graph Inductive Reasoning</h2><p>通过提示小模型得到该问题的多条推理路径和假设答案，再将这些推理路径和假设答案输入给一个强大的通用大模型，通过大模型及其内部知识进行归纳整理得到最终的答案。</p>
<p><img src="/GCR/Graph-Inductive-Reasoning.png" alt="Graph-Inductive-Reasoning"></p>
<h1 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h1><h2 id="思路学习"><a href="#思路学习" class="headerlink" title="思路学习"></a>思路学习</h2><p>对实验步骤进行客观陈述，数据集、baseline、评估指标、实现过程等</p>
<p>说明你的实验具有什么效果，和基线相比有什么突出点</p>
<p>你的实验结果怎么和你的创新点相关联</p>
<p>基本：</p>
<p>可以在实验之前通过问题的方式告诉自己都需要做什么实验</p>
<p>通过实验告诉读者，你提出的框架或模型和基线相比有什么不同、提升……</p>
<p>通过实验告诉读者，你提出的框架或模型解决了什么问题</p>
<p>通过实验告诉读者，你提出的框架或模型可以怎么扩展，或应用在哪些下游任务……</p>
<h2 id="Implementations"><a href="#Implementations" class="headerlink" title="Implementations"></a>Implementations</h2><p>我们使用KG-Trie索引从问题实体开始的2个跳内的所有推理路径。对于LLM，我们使用微调Llama3-8B 作为KG专用LLM。我们通过图约束解码生成前10条推理路径和假设答案。我们采用ChatGPT和GPT-4o-mini作为归纳推理的通用LLMs。</p>
<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p><img src="/GCR/result.png" alt="result"></p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>提出了一种新的LLM推理范式，称为图约束推理（GCR），通过引入结构化KG来消除幻觉，保证推理的可靠性。</p>
<p>为了将LLMs中的非结构化推理与KGs中的结构化知识联系起来，我们提出了一种KG-Trie，利用基于Trie的索引对KGs中的路径进行编码。</p>
<p>使用大小模型协同作用，结合图推理和归纳推理生成最终答案。</p>
]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>LLM</tag>
        <tag>Knowledge Graph</tag>
        <tag>KG-Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>How to write related work</title>
    <url>/How-to-write-related-work.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>参考链接：<a href="https://guidetogradschoolsurvival.wordpress.com/2011/04/08/how-to-write-related-work/">https://guidetogradschoolsurvival.wordpress.com/2011/04/08/how-to-write-related-work/</a></p>
<p>相关工作部分通常在引言之后，有些论文也会放在实验章节后面。相关工作又称为“小综述”，用较短的篇幅介绍与你自己研究有所关联的他人成ß果——可能是你研究的基础，也可能是其他人针对同一问题提出的不同解决方案。</p>
<h2 id="关于如何撰写相关工作部分"><a href="#关于如何撰写相关工作部分" class="headerlink" title="关于如何撰写相关工作部分"></a>关于如何撰写相关工作部分</h2><ol>
<li>将和你的研究相关联的文献按照渐进式叙述或对比总结式表述，每个文献使用两三句话总结关键点进行介绍；</li>
<li>将你要提及的多个文献整理归类为一个类别进行整体介绍，再在介绍的段落之中插入引用；</li>
<li>精选最重要的文献，并只讨论这些核心文献。使用一个段落详细介绍该文献的内容，表述和你的研究的关联性；</li>
</ol>
<p>就目前为止，我看的大多数论文还是采用第一种和第二种方法撰写相关工作内容。</p>
<h2 id="表述方式"><a href="#表述方式" class="headerlink" title="表述方式"></a>表述方式</h2><p>渐进式叙述</p>
<p>按时间演进进行叙述：例如：在这一领域，早期主要研究什么方法，但是有什么问题；现有的方法集中于什么什么，取得了什么效果，然而……</p>
<p>按方法论分别叙述：根据你的研究内容将相关联的研究方法分为几类，逐个叙述；</p>
<p>对比总结，例如：现有方法A是什么思路，用于什么场景，现有方法B采用了另一种思路，取得了什么效果……</p>
<h2 id="相关工作部分的另一个关键点"><a href="#相关工作部分的另一个关键点" class="headerlink" title="相关工作部分的另一个关键点"></a>相关工作部分的另一个关键点</h2><p>如果你决定提及某篇文献，它必须与你的研究有具体、明确的关联。你应该能够（轻松地）为选择的每一篇文献进行辩护，说明选择它的理由及其重要性。有些文献很容易解释——它们是你研究的基础，或者提供了解决同一问题的其他方案。但有些文献则较难论证。如果发现难以解释其关联性，那么你就需要自问：为什么要纳入这篇文献？它是否真的必要？</p>
<h2 id="读论文的建议"><a href="#读论文的建议" class="headerlink" title="读论文的建议"></a>读论文的建议</h2><p>建立文献笔记：每阅读一篇论文，就写下简短总结并标注其核心部分。这样，在需要判断相关性时，你可以参考自己的笔记摘要，而无需依赖论文原文的摘要。</p>
<p>顺藤摸瓜：利用所读论文的参考文献列表来寻找其他相关文献。如果某篇论文与你的课题紧密相关，那么它引用的文献很可能也高度相关，值得一读。</p>
<p>追踪目标期刊&#x2F;会议：浏览你计划投稿的期刊或会议的过往发表记录，很可能在其中找到与你主题相关的论文。</p>
<p>明确关联性：在撰写关于某篇文献的段落时，确保你能回答”这项研究如何与我的工作相关联？”这个问题。如果你回答不了，那就需要考虑是否真的有必要将其纳入。</p>
<p>最后记录一下今天看见的名言：见人皆所见，思人所未思。</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>thought</tag>
        <tag>related work</tag>
      </tags>
  </entry>
  <entry>
    <title>KG-R1：基于强化学习的高效可转移的智能体知识图谱检索增强生成</title>
    <url>/KG-R1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p>code source ：<a href="https://github.com/Jinyeop3110/KG-R1">https://github.com/Jinyeop3110/KG-R1</a>.</p>
<p>paper source ：<a href="https://arxiv.org/abs/2509.26383">https://arxiv.org/abs/2509.26383</a></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>知识图谱检索增强生成（KG-RAG）通过将大型语言模型（LLM）与结构化、可验证的知识图谱（KG）相结合，从而减轻模型幻觉问题，并显式呈现其推理过程。然而，许多KG-RAG系统由多个LLM模块（如规划、推理和响应）组成，增加了推理成本，并将推理行为绑定到特定的目标知识图谱上。为此，我们引入了KG-R1，一种基于强化学习（RL）的智能体知识图谱检索增强生成（KGRAG）框架。KG-R1利用一个单智能体与知识图谱进行交互并将知识图谱作为其环境，在每个步骤学习检索，并将检索到的信息合并到KG-R1的推理和生成中。该过程通过端到端的强化学习进行优化。在跨知识图谱问答（KGQA）基准的实验中，证明了方法的有效性和可迁移性：与先前的使用更大的基础模型或微调的模型的多模块工作流方法相比，KG-R1方法使用Qwen-2.5-3B模型，用更少的token取得了更好的准确性。KG-R1支持即插即用，经过训练后，它在其他知识图谱上也能保持很高的准确性，无需再训练。</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>典型的KG-RAG采用由四个主要子任务组成的模块化工作流：检索、推理、审查、响应</p>
<p>1、检索以查询KG中的事实</p>
<p>2、推理以处理检索到的信息</p>
<p>3、审查以验证逻辑一致性</p>
<p>4、响应以综合最终答案</p>
<p>存在问题：</p>
<p>1、现有的检索增强生成方法计算成本高：</p>
<p>基于提示的方法通过多次和LLM进行交互，不可避免的导致LLM call、时延和使用token不断累积</p>
<p>2、对其他知识图谱或更新后的知识图谱的可迁移性和可泛化性差：</p>
<p>还有一些基于提示和微调的方法在当前知识图谱中得到了较好的调优结果，当迁移到新的知识图谱时，不能保证性能会完整保留。</p>
<p>KG-R1，一种采用端到端多轮强化学习的智能体KG-RAG系统。</p>
<p>KG-R1的体系结构有两个组件：单个轻量模型作为智能体和知识图谱检索服务器（作为环境）。知识图谱检索服务器托管知识图以及一组检索操作。轻量模型智能体迭代地执行推理和生成步骤，然后执行多轮检索操作，每个决策都基于知识图谱检索服务器获取的知识生成，并获取最终答案。</p>
<h2 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h2><p>1、KG-R1框架：引入强化学习使得轻量模型学习到最优的推理策略，使智能体在知识图谱环境中交替进行推理和检索操作得到最终答案。</p>
<p>2、有效的推理过程：KG-R1在使用轻量开源模型和较低的计算成本之下取得了和比较通用模型（如GPT4等）相同甚至更好的效果。</p>
<p>3、即插即用，跨知识图谱可迁移性：经过训练的KG-R 可轻松迁移至各种知识图谱，并保持KG-RAG的良好性能。</p>
<h2 id="KG-R1框架总体概述"><a href="#KG-R1框架总体概述" class="headerlink" title="KG-R1框架总体概述"></a>KG-R1框架总体概述</h2><p>KG-R1将KG-RAG转换为与KG接口（KG检索服务器）的多轮交互。</p>
<p>作者优先考虑两个设计原则。</p>
<p>1、设计了一个单代理体系结构，它可以简化部署并实现高效、低成本的推理。</p>
<p>2、构建了一个与模式无关（schema-agnostic）的知识图谱检索服务器，避免引入针对特定知识图谱的假设，从而在不同的知识图谱之间保持良好的可移植性。 </p>
<p>问题</p>
<p>什么是KG-RAG？</p>
<p>什么叫与模式无关？</p>
<p>指系统的设计不依赖某一个特定的 schema 细节，不假设“图里一定有某种具体的实体类型&#x2F;关系名”，因此可以在不同结构的知识图谱之间复用。</p>
<p>KG-R1 Framework</p>
<p><img src="/KG-R1/KG-R1-freamwork.png" alt="KG-R1-freamwork"></p>
<p>1、知识图谱检索服务</p>
<p>为知识图谱搭建一个后端检索服务，并提供一个单跳检索操作集接口$U_{ret}$，</p>
<p>2、KG-R1智能体</p>
<p>智能体运行包含两个过程，1、生成过程，2、执行过程</p>
<p>生成阶段</p>
<p>包含两个部分响应，一个是思考过程think，一个是检索执行动作 KG Query或者最终答案Answer。</p>
<p>执行阶段：</p>
<p>使用一个精确匹配解析器，解析生成阶段的响应并映射到知识图谱检索服务的操作集上（也可能是响应错误或者预测结果答案），如果解析是答案交互终止，如果是在操作集中，则会生成一个观察结果用于下一轮交互。</p>
<p>提示词如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">You are a helpful assistant. Answer the given question. You can query from knowledge base provided to you to answer the question. You can query knowledge up to [H] <span class="built_in">times</span>. You must first conduct reasoning inside &lt;think&gt;...&lt;/think&gt;. If you need to query knowledge, you can <span class="built_in">set</span> a query statement between &lt;kg-query&gt;...&lt;/kg-query&gt; to query from knowledge base after &lt;think&gt;...&lt;/think&gt;. When you have the final answer, you can output the answer inside &lt;answer&gt;...&lt;/answer&gt;. </span><br><span class="line">KG Query Server Instruction : [KG query server instruction] </span><br><span class="line">Question: [question]. </span><br><span class="line">Assistant:</span><br></pre></td></tr></table></figure>



<p>两个可验证的命题：</p>
<p>检索操作集的完整性：对任意推理路径，通过该操作集的检索动作，都可以得到完整的推理路径。</p>
<p>检索操作无约束可迁移性：对于任何其他的后端知识图谱检索任务，该操作集都可以无缝适用。</p>
<h2 id="KG-R1-Training-With-RL"><a href="#KG-R1-Training-With-RL" class="headerlink" title="KG-R1 Training With RL"></a>KG-R1 Training With RL</h2><p>通过使用GRPO强化学习算法微调轻量化开源模型找到一个策略，使得KG-R1 智能体学会通过多轮交互有效检索知识图谱上的推理路径并生成精确的答案。</p>
<p>奖励函数：单轮回合奖励 + 全局结果奖励</p>
<p>回合奖励：</p>
<p><img src="/KG-R1/%E5%A5%96%E5%8A%B1%E5%87%BD%E6%95%B01.png" alt="奖励函数1"></p>
<p><img src="/KG-R1/%E5%A5%96%E5%8A%B1%E5%8F%8A%E4%BC%98%E5%8A%BF%E5%87%BD%E6%95%B0.png" alt="奖励及优势函数"></p>
<p>同一批 rollouts 里，谁比平均表现好 → 正优势，差 → 负优势</p>
<p>用 同一个 group 基线，就不需要额外训练一个 value 网络（这就是 GRPO 最大的区别）</p>
<p>把优势分到每一个token：</p>
<p><img src="/KG-R1/%E5%B9%B3%E5%9D%87%E5%88%86%E9%85%8Dtoken.png" alt="平均分配token"></p>
<p>在第 nnn 条轨迹第 ttt 轮的输出文本中，有一连串 token </p>
<p>只对「agent 生成的部分」（不包括系统 prompt、用户 problem）打梯度</p>
<p>然后把同一个 step 的优势分给该 step 的每个有效 token</p>
<p>本质目的：无论增大还是减小概率，每次更新都别太猛。</p>
<p><img src="/KG-R1/%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0.png" alt="目标函数"></p>
<p>重要性采样比率：</p>
<p><img src="/KG-R1/%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7%E7%AD%96%E7%95%A5.png" alt="重要性采样策略"></p>
<p>KL散度的作用：限制当前策略要偏离参考策略 （通常是初始模型）太远，防止训练发散。</p>
<p>当当前策略和初始策略的比例相差太多时，即使前面的PPO-clip将策略提高太多时，后面的KL散度也可以按照一定的比例进行惩罚。</p>
<p><strong>在每个 token 上做一个 PPO 式的策略梯度更新</strong></p>
<ul>
<li>用 <strong>group-relative turn-level advantage</strong> 说“这一整轮行为好不好”；</li>
<li>用 ρ​ 和 clip 控制单步更新强度；</li>
<li>用 KL 把策略拉回到原始 SFT 模型附近，保证稳定；最后对所有 rollout  回合 token 求和，得到整体的 RL 目标 J(θ)​。</li>
</ul>
<h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><p>1、测试KG-R1在KG训练集上训练后的性能和效率</p>
<p>2、测试KG-R1迁移到不同KG到效果</p>
<p>对比基线:</p>
<p>无 KG 方法: Vanilla LLM, Chain-of-Thought (CoT)。</p>
<p>KG-RAG 方法: RoG (微调 LLaMA2-7B), ToG (GPT-3.5), ReKnoS (GPT-4o-mini) 。</p>
<p>训练数据: 在 WebQSP (Freebase子集) 和 CWQ (Complex WebQuestions, 复杂多跳) 上进行训练 。</p>
<h3 id="对比实验结果"><a href="#对比实验结果" class="headerlink" title="对比实验结果"></a>对比实验结果</h3><p><img src="/KG-R1/result_comparison.png" alt="result_comparison"></p>
<h3 id="跨图谱迁移实验结果"><a href="#跨图谱迁移实验结果" class="headerlink" title="跨图谱迁移实验结果"></a>跨图谱迁移实验结果</h3><p>跨图谱迁移能力</p>
<ol>
<li>直接使用在 WebQSP 或 CWQ 上训练好的 Agent 模型。</li>
<li>不进行任何微调，直接更换后端的 KG Server 数据源。</li>
<li>在全新的数据集上进行测试。</li>
</ol>
<p><img src="/KG-R1/cross_result.png" alt="cross_result"></p>
<h3 id="消融实验结果"><a href="#消融实验结果" class="headerlink" title="消融实验结果"></a>消融实验结果</h3><p><img src="/KG-R1/ablation_result.png" alt="ablation_result"></p>
]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>KG-R1</tag>
        <tag>RL</tag>
        <tag>KG-RAG</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程</title>
    <url>/Multithreading.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>多线程是指在一个程序中同时执行多个线程，每个线程都有自己独立的执行路径。在多线程中，程序的执行可以同时进行多个任务，从而提高系统的资源利用率和响应性能。</p>
<p>在传统的单线程编程模型中，程序按照顺序执行，一次只处理一个任务。这种方式在某些情况下可能会导致效率低下或者无法满足需求。而多线程通过将任务拆分为多个子任务，并且在不同的线程上同时执行，从而实现并发处理。</p>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>操作系统层面划分线程状态</p>
<p><img src="/Multithreading/thread-status.png" alt="操作系统层面划分线程状态"></p>
<p>java代码层面划分线程状态</p>
<p><img src="/Multithreading/thread-status-java.png" alt="java代码层面划分线程状态"></p>
<h2 id="四种创建线程的方式"><a href="#四种创建线程的方式" class="headerlink" title="四种创建线程的方式"></a>四种创建线程的方式</h2><h3 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h3><p>继承 Thread 类并重写 run() 方法，直接创建 Thread 子类对象并调用 start() 方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);  <span class="comment">// 调用父类 Thread 的构造函数设置名称</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;Thread ：&#123;&#125;&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;haibara&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<h3 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h3><p>实现 Runnable 接口的 run() 方法，使用 Thread 类的构造函数传入 Runnable 对象，调用 start() 方法启动线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;Runable ：&#123;&#125;&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>(), <span class="string">&quot;xudu&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<h3 id="使用-Callable-和-FutureTask"><a href="#使用-Callable-和-FutureTask" class="headerlink" title="使用 Callable 和 FutureTask"></a>使用 Callable 和 FutureTask</h3><p>实现 Callable 接口的 call() 方法，使用 FutureTask 包装 Callable 对象，再通过 Thread 启动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Callable hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;yinuo&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<h3 id="使用自定义线程池"><a href="#使用自定义线程池" class="headerlink" title="使用自定义线程池"></a>使用自定义线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">poolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">4</span>,</span><br><span class="line">                <span class="number">30</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NamedThreadFactory</span>(<span class="string">&quot;xudu&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        poolExecutor.execute(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        poolExecutor.shutdown();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NamedThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String prefix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NamedThreadFactory</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.prefix = prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        t.setName(prefix + <span class="string">&quot;-&quot;</span> + index.getAndIncrement());</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Runnable vs Callable：</p>
<p>Runnable 的 run() 方法不返回结果，不能抛出检查异常；Callable 的 call() 方法可以返回结果，并允许抛出检查异常。使用 Callable 更适合需要返回结果或处理异常的并发任务。</p>
<p>Java语言支持多实现，一个类可以实现多个接口，因此可以更灵活地创建线程。</p>
<p>通过实现Runnable接口，可以将任务逻辑与线程的启动和管理逻辑分离，使代码更清晰、结构更合理。</p>
<p>Runnable对象可以作为参数传递给其他线程或线程池，实现更高级的线程管理和复用。</p>
<h2 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h2><ul>
<li><p>start()</p>
<p>启动一个新线程，在新的线程运行 run 方法中的代码。start 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次会出现IllegalThreadStateException</p>
</li>
<li><p>run()</p>
<p>新线程启动后会调用的方法。如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象，来覆盖默认行为</p>
</li>
<li><p>join() &#x2F; join(long n)</p>
<p>等待线程运行结束</p>
</li>
<li><p>getId()</p>
<p>获取线程长整型的唯一 id</p>
</li>
<li><p>getName() &#x2F; setName(String)</p>
<p>获取&#x2F;修改 线程名</p>
</li>
<li><p>getPriority() &#x2F; setPriority(int)</p>
<p>获取&#x2F;修改 线程优先级。java中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率</p>
</li>
<li><p>getState()</p>
<p>获取线程状态，NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED</p>
</li>
<li><p>isInterrupted()</p>
<p>判断是否被打断， 不会清除打断标记</p>
</li>
<li><p>isAlive()</p>
<p>线程是否存活（还没有运行完毕）</p>
</li>
<li><p>interrupt()</p>
<p>打断线程，如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并清除打断标记；如果打断的正在运行的线程，则会设置打断标记 ；park 的线程被打断，也会设置打断标记</p>
</li>
<li><p>interrupted()</p>
<p>判断当前线程是否被打断 ，会清除打断标记</p>
</li>
<li><p>currentThread()</p>
<p>获取当前正在执行的线程</p>
</li>
<li><p>sleep(long n)</p>
<p>让当前执行的线程休眠n毫秒，休眠时让出 cpu 的时间片给其它线程</p>
</li>
<li><p>yield()</p>
<p>提示线程调度器让出当前线程对CPU的使用，主要是为了测试和调试</p>
</li>
</ul>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><h3 id="出现线程安全性问题的条件"><a href="#出现线程安全性问题的条件" class="headerlink" title="出现线程安全性问题的条件"></a>出现线程安全性问题的条件</h3><ol>
<li>在多线程的环境下</li>
<li>必须有共享资源</li>
<li>对共享资源进行非原子性操作</li>
</ol>
<h3 id="解决线程安全性问题的方法"><a href="#解决线程安全性问题的方法" class="headerlink" title="解决线程安全性问题的方法"></a><strong>解决线程安全性问题的方法</strong></h3><ul>
<li>针对多个线程操作同一共享资源——不共享资源（ThreadLocal、不共享、操作无状态化、不可变）</li>
<li>针对多个线程进行非原子性操作——将非原子性操作改成原子性操作（使用加锁机制来保证可见性和有序性以及原子性、使用JDK自带的原子性操作的类、JUC提供的相应的并发工具类）</li>
</ul>
<h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a><strong>性能问题</strong></h3><ol>
<li>线程的生命周期开销非常高。在线程切换时存在CPU上下文切换开销，内存同步也存在着开销。</li>
<li>消耗过多的CPU资源。如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争CPU资源时还将产生其他性能的开销。</li>
<li>降低稳定性</li>
</ol>
<p>什么是死锁？</p>
<p>两个或多个线程在执行过程中，因争夺资源而形成的一种相互等待的状态，若无外力干预，这些线程都将无法继续执行。</p>
<p>什么是活锁？</p>
<p>多个线程持续改变状态以响应对方的行为，但始终无法推进程序进展的一种状态。</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="synchronized的用法"><a href="#synchronized的用法" class="headerlink" title="synchronized的用法"></a>synchronized的用法</h3><p>修饰方法</p>
<p>修饰普通方法，相当于锁当前对象，调用者，即指 this对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修饰静态方法，相当于锁当前类对象，也指 className.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  log.info(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>修饰代码块【可以缩小锁的范围，提升性能】</p>
<p>锁普通对象和锁this</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁定类对象className.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(SynchronizedTest.class) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h3><p>常用实现：ReentrantLock</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>java 中的原子类是通过使用硬件提供的原子操作指令（如 CAS，Compare-And-Swap）来确保操作的原子性，从而避免线程竞争问题。</p>
<p>常用的原子类有以下几种：</p>
<ol>
<li>AtomicInteger：用于操作整数的原子类，提供了原子性的自增、自减、加法等操作。</li>
<li>AtomicLong：与 AtomicInteger 类似，但用于操作 long 型数据。</li>
<li>AtomicBoolean：用于操作布尔值的原子类，提供了原子性的布尔值比较和设置操作。</li>
<li>AtomicReference：用于操作对象引用的原子类，支持对引用对象的原子更新。</li>
<li>AtomicStampedReference：在 AtomicReference 的基础上，增加了时间戳或版本号的比较，避免了 ABA 问题。</li>
<li>AtomicIntegerArray 和 AtomicLongArray：分别是 AtomicInteger 和 AtomicLong 的数组版本，提供了对数组中各个元素的原子操作。</li>
</ol>
<h3 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h3><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>作用： 一个线程（或多个）等待其他线程完成操作。</p>
<p>用法： 适用于主线程需要等待多个子线程完成任务的场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        latch.countDown(); <span class="comment">// 任务完成，计数器减一</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">latch.await(); <span class="comment">// 等待所有任务完成</span></span><br><span class="line">System.out.println(<span class="string">&quot;所有任务都完成了&quot;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>作用：让一组线程到达一个共同的同步点，然后一起继续执行。常用于分阶段任务执行。</p>
<p>用法：适用于需要所有线程在某个点都完成后再继续的场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>, () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;所有线程都到达了屏障点&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        barrier.await(); <span class="comment">// 等待其他线程</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br></pre></td></tr></table></figure>



<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>作用： 控制访问资源的线程数，可以用来实现限流或访问控制。</p>
<p>用法： 在资源有限的情况下，控制同时访问的线程数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    semaphore.acquire(); <span class="comment">// 获取许可</span></span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    semaphore.release(); <span class="comment">// 释放许可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p>作用： 是一个线程安全的队列，支持阻塞操作，适用于生产者-消费者模式。</p>
<p>用法： 生产者线程将元素放入队列，消费者线程从队列中取元素，队列为空时消费者线程阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">producer</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        queue.put(<span class="string">&quot;item&quot;</span>); <span class="comment">// 放入元素</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">consumer</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> queue.take(); <span class="comment">// 取出元素</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br></pre></td></tr></table></figure>



<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>线程池是一种池化技术，用于预先创建并管理一组线程，避免频繁创建和销毁线程的开销，提高性能和响应速度。</p>
<p>它几个关键的配置包括：核心线程数、最大线程数、空闲存活时间、工作队列、拒绝策略。</p>
<p>主要工作原理如下：</p>
<ol>
<li>默认情况下线程不会预创建，任务提交之后才会创建线程（不过设置 prestartAllCoreThreads 可以预创建核心线程）。</li>
<li>当核心线程满了之后不会新建线程，而是把任务堆积到工作队列中。</li>
<li>如果工作队列放不下了，然后才会新增线程，直至达到最大线程数。</li>
<li>如果工作队列满了，然后也已经达到最大线程数了，这时候来任务会执行拒绝策略。</li>
<li>如果线程空闲时间超过空闲存活时间，并且当前线程数大于核心线程数的则会销毁线程，直到线程数等于核心线程数（设置 allowCoreThreadTimeOut 为 true 可以回收核心线程，默认为 false）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * corePoolSize:线程池的核心大小，当提交一个任务到线程池时，线程池会创建一个线程来执行任务</span></span><br><span class="line"><span class="comment"> *              即使其他空闲的基本线程能够执行新任务也会创建线程，如需要执行的任务数大于线</span></span><br><span class="line"><span class="comment"> *              程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法</span></span><br><span class="line"><span class="comment"> *              线程池会提前创建并启动所有基本线程。</span></span><br><span class="line"><span class="comment"> * maximumPoolSize:线程池最大大小，线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数</span></span><br><span class="line"><span class="comment"> *                 小于最大线程数大于等于核心线程数，则线程池会再创建新的线程执行任务。如果使用</span></span><br><span class="line"><span class="comment"> *                 了无界的任务队列这个参数就没什么效果。</span></span><br><span class="line"><span class="comment"> * keepAliveTime:临时线程活动保持时间，线程池的工作线程空闲后，保持存活的时间。所以如果任务很多</span></span><br><span class="line"><span class="comment"> *               并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</span></span><br><span class="line"><span class="comment"> * TimeUnit:临时线程活动保持时间的单位，可选的单位有天(DAYS)，小时(HOURS)，分钟(MINUTES)，</span></span><br><span class="line"><span class="comment"> *          毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, </span></span><br><span class="line"><span class="comment"> *          千分之一微秒)</span></span><br><span class="line"><span class="comment"> * workQueue:任务对列，用于保存等待执行的任务的阻塞队列</span></span><br><span class="line"><span class="comment"> *           - ArrayBlockingQueue：基于数组结构的有界阻塞队列</span></span><br><span class="line"><span class="comment"> *           - LinkedBlockingQueue：基于链表的阻塞队列,如果没构造函数没传入队列大小则为无界队列</span></span><br><span class="line"><span class="comment"> *                                  Executors.newFixedThreadPool()使用了这个队列</span></span><br><span class="line"><span class="comment"> *           - SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用</span></span><br><span class="line"><span class="comment"> *                               移除操作，否则插入操作一直处于阻塞状态</span></span><br><span class="line"><span class="comment"> *                               Executors.newCachedThreadPool使用了这个队列</span></span><br><span class="line"><span class="comment"> *           - PriorityBlockingQueue：个具有优先级得无限阻塞队列</span></span><br><span class="line"><span class="comment"> * threadFactory:用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字，</span></span><br><span class="line"><span class="comment"> *               Debug和定位问题时非常有帮助。</span></span><br><span class="line"><span class="comment"> * handler:当队列和线程池都满了，必须采取一种策略处理提交的新任务。</span></span><br><span class="line"><span class="comment"> *         - AbortPolicy：默认策略，无法处理新任务时抛出异常</span></span><br><span class="line"><span class="comment"> *         - CallerRunsPolicy：使用调用者所在线程来运行任务</span></span><br><span class="line"><span class="comment"> *         - DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务</span></span><br><span class="line"><span class="comment"> *         - DiscardPolicy：不处理，丢弃掉</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, </span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span>;</span><br></pre></td></tr></table></figure>



<h3 id="线程池工作流"><a href="#线程池工作流" class="headerlink" title="线程池工作流"></a>线程池工作流</h3><p><img src="/Multithreading/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E6%B5%81.png" alt="线程池工作流"></p>
<blockquote>
<p>线程池采用“懒加载”方式创建线程，以降低资源消耗并提高系统稳定性。</p>
</blockquote>
<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><h3 id="什么是悲观锁？"><a href="#什么是悲观锁？" class="headerlink" title="什么是悲观锁？"></a>什么是悲观锁？</h3><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。</p>
<p>像 Java 中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p>
<p>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题（线程获得锁的顺序不当时），影响代码的正常运行。</p>
<h3 id="什么是乐观锁？"><a href="#什么是乐观锁？" class="headerlink" title="什么是乐观锁？"></a>什么是乐观锁？</h3><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）</p>
<p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败并重试，这样同样会非常影响性能，导致 CPU 飙升。</p>
<h3 id="如何实现乐观锁？"><a href="#如何实现乐观锁？" class="headerlink" title="如何实现乐观锁？"></a>如何实现乐观锁？</h3><h4 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h4><p>一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p>举一个简单的例子：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p>
<ol>
<li>操作员 A 此时将其读出（ version&#x3D;1 ），并从其帐户余额中扣除 50（ 100-$50 ）。</li>
<li>在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ version&#x3D;1 ），并从其帐户余额中扣除 20 （ 100-$20 ）。</li>
<li>操作员 A 完成了修改工作，将数据版本号（ version&#x3D;1 ），连同帐户扣除后余额（ balance&#x3D;$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li>
<li>操作员 B 完成了操作，也将版本号（ version&#x3D;1 ）试图向数据库提交数据（ balance&#x3D;$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，而数据库记录当前版本为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li>
</ol>
<p>这样就避免了操作员 B 用基于 version&#x3D;1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。</p>
<h4 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h4><p>CAS 的全称是 Compare And Swap（比较与交换） ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p>
<p>只有当内存中的值等于我期望的旧值时，才把它更新成新值；否则失败。</p>
<p>公式描述：CAS(V, A, B)</p>
<p>V：内存中的变量（当前值）</p>
<p>A：期望的旧值</p>
<p>B：要更新的新值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行逻辑，以下比较和赋值是 一个不可分割的原子操作</span></span><br><span class="line"><span class="keyword">if</span> V == A:</span><br><span class="line">    V = B   <span class="comment">// 更新成功</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    不更新 <span class="comment">// 更新失败</span></span><br></pre></td></tr></table></figure>

<p>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p>
<p>存在的问题：</p>
<p>ABA 问题描述</p>
<p>线程 1 读取 A</p>
<p>线程 2 把 A → B → A</p>
<p>线程 1 CAS 发现还是 A，于是成功</p>
<p>但数据其实被改过</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>开始是结束的开始？愿我们都能成为生活的高手！</title>
    <url>/We-Made-a-Beautiful-Bouquet.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>有着诸多相同的兴趣爱好的恋人</p>
<p>最后却以遗憾结束……</p>
<p><img src="/We-Made-a-Beautiful-Bouquet/00.webp" alt="00"></p>
<h2 id="邂逅、同频"><a href="#邂逅、同频" class="headerlink" title="邂逅、同频"></a>邂逅、同频</h2><p>山音麦、八谷绢</p>
<p>两个错过末班地铁的大学生意外发现两人的兴趣爱好出奇的一致</p>
<p>两人都喜欢相同的电影、音乐和文学作品</p>
<p>都喜欢用电影票当书签</p>
<p>都好奇石头剪刀布的规则，为什么布能赢石头？明明石头能将布戳个洞</p>
<p>还都一起错过了同一个喜剧专场</p>
<p>在几次交谈中</p>
<p>两人互生好感</p>
<p>渐生情愫</p>
<p><img src="/We-Made-a-Beautiful-Bouquet/01.webp" alt="01"></p>
<h2 id="热恋、纯粹"><a href="#热恋、纯粹" class="headerlink" title="热恋、纯粹"></a>热恋、纯粹</h2><p>毕业，同居</p>
<p>两人在多摩川河畔的出租屋过着惬意的日子</p>
<p>麦以兼职插画赚钱</p>
<p>绢在冰淇淋店兼职</p>
<p>领养黑猫男爵</p>
<p>去老夫妇的面包房买喜欢的面包</p>
<p>下班后回家的三十分钟散步时间</p>
<p>是两人最温馨的记忆</p>
<p>阳台上，麦对绢说</p>
<p>我的人生目标就是，一直跟你过现在这样的生活。</p>
<p><img src="/We-Made-a-Beautiful-Bouquet/02.webp" alt="02"></p>
<h2 id="现实、错位"><a href="#现实、错位" class="headerlink" title="现实、错位"></a>现实、错位</h2><p>没有坚实的物质基础的保障下</p>
<p>理想的乌托邦式的恋爱生活不能长久</p>
<p>一张插画由一千日元降到三张插画一千日元（约44RMB）</p>
<p>麦不得不开始找工作</p>
<p>绢考上了会计师证</p>
<p>先找到了一份朝九晚五的工作</p>
<p>随后几经面试</p>
<p>麦也入职一家初创物流公司</p>
<p>由此开始</p>
<p>生活、工作、理想不能同时兼顾</p>
<p>绢在下班后可以看书、打游戏，维持喜好</p>
<p>麦却不得不频繁加班，作策划</p>
<p>两人都想照顾对方的感受</p>
<p>但慢慢出现分歧</p>
<p>两双不同鞋子的特写</p>
<p>后备箱中扔掉的书籍</p>
<p>都表明两人不再同频</p>
<p>刚开始的两人只是想过好普通生活</p>
<p>最后发现并不容易</p>
<p><img src="/We-Made-a-Beautiful-Bouquet/03.webp" alt="03"></p>
<h2 id="终焉、释然"><a href="#终焉、释然" class="headerlink" title="终焉、释然"></a>终焉、释然</h2><p>在朋友的婚礼上</p>
<p>两人向各自的好友袒露心声</p>
<p>现在的爱情和完全不同于刚开始的模样</p>
<p>重回告白的地点</p>
<p>看见一对情侣</p>
<p>和当初的自己一样</p>
<p>热烈、纯真、充满可能</p>
<p>又想到当初的甜蜜和当下的遗憾</p>
<p>两人相拥落泪</p>
<p>决定分手</p>
<p><img src="/We-Made-a-Beautiful-Bouquet/04.webp" alt="04"></p>
<p>电影好似绝大多数情侣的真实写照</p>
<p>从百分百合拍到长时间消耗和平分手</p>
<p>本质还是没有物质保障</p>
<p>为了更好的生活</p>
<p>必须要放弃一部分</p>
<p>麦的理想主义最终被工作的琐碎磨灭</p>
<p>作为旁观者而言</p>
<p>多希望他能平衡好工作和生活</p>
<p>想了想，即使两人衣食无忧</p>
<p>可能也有其他插曲来干扰正常的生活节奏</p>
<p><img src="/We-Made-a-Beautiful-Bouquet/05.webp" alt="05"></p>
<p>我们普通人所能借鉴的</p>
<p>只是经营好自己的生活</p>
<p>借用房客中乐瑶的名言</p>
<p>希望我们每个人，都能做生活的高手</p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>花束般的恋爱</tag>
        <tag>有村架纯</tag>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中如何执行一条select语句？</title>
    <url>/How_to_execute_a_select_statement_in_MySQL.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>由一条select语句的执行流程，了解MySQL的内部结构！</p>
<h2 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h2><p>下图是MySQL的整体架构，主要分为两层，Server层和存储引擎。</p>
<img src="http://picgo.xuduyinuo.cn/imgs/20260104095558721.webp" alt="MySQL架构图" style="zoom: 25%;" />



<p>Server层：负责建立连接、分析和执行 SQL</p>
<p>包含核心功能模块：连接器、查询缓存（8.0版本移除）、解析器、预处理器、优化器、执行器、内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（存储过程、触发器、视图）。</p>
<p>存储引擎：负责数据的存储和提取</p>
<p>支持多种存储引擎，不同存储引擎共用同一个Server层，默认存储引擎为InnoDB。</p>
<h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>使用MySQL之前需要先进行连接（登录）MySQL服务，然后才能执行SQL语句，连接语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="operator">-</span>h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数；</span><br><span class="line"># <span class="operator">-</span>u 指定用户名，管理员角色名为 root；</span><br><span class="line"># <span class="operator">-</span>p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码</span><br><span class="line">mysql <span class="operator">-</span>h$ip <span class="operator">-</span>u$<span class="keyword">user</span> <span class="operator">-</span>p</span><br></pre></td></tr></table></figure>

<p>连接过程需要经过TCP三次握手，连接之前确保启动MySQL服务，使用正确的用户名和密码，连接成功如下</p>
<img src="http://picgo.xuduyinuo.cn/imgs/20260104102100681.webp" alt="image-20260104102048666" style="zoom:50%;" />

<p>连接成功后连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p>
<p>查看当前MySQL服务被多少个客户端连接：show processlist</p>
<p><img src="http://picgo.xuduyinuo.cn/imgs/20260104103235296.webp" alt="image-20260104103233284"></p>
<p>空闲连接</p>
<p>MySQL 定义了空闲连接的最大空闲时长，由 wait_timeout 参数控制的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。</p>
<p>使用的是 kill connection + id 命令手动断开空闲连接。</p>
<p>MySQL 的连接数限制</p>
<p>MySQL 服务支持的最大连接数由 max_connections 参数控制，默认是 151 。</p>
<p>短连接和长连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 短连接</span><br><span class="line">连接 mysql 服务（TCP 三次握手）</span><br><span class="line">执行<span class="keyword">sql</span></span><br><span class="line">断开 mysql 服务（TCP 四次挥手）</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 长连接</span><br><span class="line">连接 mysql 服务（TCP 三次握手）</span><br><span class="line">执行<span class="keyword">sql</span></span><br><span class="line">执行<span class="keyword">sql</span></span><br><span class="line">执行<span class="keyword">sql</span></span><br><span class="line">....</span><br><span class="line">断开 mysql 服务（TCP 四次挥手）</span><br></pre></td></tr></table></figure>

<p>长连接可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接</p>
<p>长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。</p>
<p>总结连接器流程：</p>
<p>1、与客户端进行 TCP 三次握手建立连接；</p>
<p>2、校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</p>
<p>3、如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</p>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>连接器得工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。</p>
<p>在8.0之前的版本中，如果SQL是select语句，MySQL会先进行查询缓存，如果命中则直接返回，未命中则继续执行。</p>
<p>对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。</p>
<h2 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h2><p>在正式执行 SQL 查询语句之前， MySQL 会先对 SQL 语句做解析。</p>
<p>词法分析：</p>
<p>把字符串切成 token，MySQL 会根据你输入的字符串识别出关键字</p>
<p>语法分析：</p>
<p>根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法，如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</p>
<img src="http://picgo.xuduyinuo.cn/imgs/20260104155413190.webp" alt="image-20260104155407094" style="zoom:50%;" />

<h2 id="执行SQL流程"><a href="#执行SQL流程" class="headerlink" title="执行SQL流程"></a>执行SQL流程</h2><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p>检查 SQL 查询语句中的表或者字段是否存在；</p>
<p>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列；</p>
<p>预处理器负责把解析器产出的语法结构“落到真实的库表对象上”，让一条语句从“语法正确”变成“语义可执行”。它会解析并确认语句里引用的库、表、列等对象是否存在且可访问（比如表不存在会在这一阶段直接报错），同时会把 <code>select *</code> 这类模糊表达展开成明确的列清单，必要时也会完成与权限、类型相关的基础校验。</p>
<p>它的作用是尽早发现“对象&#x2F;语义层面”的问题并把查询规格化，为后续生成执行计划提供准确输入。</p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>经过预处理阶段后，还需要为 SQL 查询语句先制定一个执行计划。</p>
<p>优化器负责为这条 SQL 选择一条成本更低的执行计划，核心就是在多种可行访问路径之间做取舍，例如决定走主键索引、二级索引还是全表扫描，以及能否利用覆盖索引来避免回表、能否使用索引下推来减少不必要的回表与记录传递等。它会基于统计信息与代价模型评估不同方案的开销，最终确定执行过程中“怎么访问数据、以什么顺序和方式取数”的策略；</p>
<p>它的作用是把同一个逻辑查询变成尽可能高效的物理执行方案，<code>EXPLAIN</code> 里看到的 key&#x2F;type&#x2F;Extra 等信息本质上就是优化器决策的外化结果。</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端。</p>
<p>负责按优化器给定的执行计划真正把查询跑起来，并在执行过程中以记录为单位与存储引擎交互：该走索引就调用引擎的索引读取接口定位第一条或下一条记录，该全表扫就让引擎顺序返回记录，然后在 Server 层对返回的记录做条件判断与表达式计算，满足条件的就逐步发送给客户端，直到读完或满足停止条件为止。在索引下推场景下，执行器会把部分原本由 Server 层做的过滤条件交给引擎在索引层先筛掉，从而减少回表次数与数据搬运。它的作用是把“计划”转化为具体的读、判、发动作，协调 Server 层与存储引擎完成整条语句的实际执行。</p>
<p>三种方式：</p>
<p>主键索引查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>以上面的SQL语句为例，这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：</p>
<blockquote>
<p>1、执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 id &#x3D; 1 交给存储引擎，让存储引擎定位符合条件的第一条记录。</p>
<p>2、存储引擎通过主键索引的 B+ 树结构定位到 id &#x3D; 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；</p>
<p>3、执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。</p>
<p>4、执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。</p>
</blockquote>
<p>全表扫描</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;iphone&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>以上面的SQL语句为例，这条查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为 ALL 进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：</p>
<blockquote>
<p>1、执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，让存储引擎读取表中的第一条记录；</p>
<p>执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户的（是的没错，Server 层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。</p>
<p>3、执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；</p>
<p>4、一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；</p>
<p>5、执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。</p>
</blockquote>
<p>索引下推</p>
<p>mysql 5.6 推出的查询优化策略。</p>
<p>索引下推能够<strong>减少</strong> <strong>二级索引</strong> 在查询时的<strong>回表操作</strong>，提高查询效率，因为它将 server 层部分负责的事交给了存储引擎层去处理。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">有一个字段如下的表，且对 age 和 reward 字段建立了联合索引。</span><br><span class="line"> id    name     age      reward</span><br><span class="line"> </span><br><span class="line"> 有如下的查询语句</span><br><span class="line"> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">and</span> reward <span class="operator">=</span> <span class="number">100000</span>;</span><br></pre></td></tr></table></figure>

<p>联合索引当遇到范围查询 (&gt;、&lt;) 就会停止匹配，也就是 <strong>age 字段能用到联合索引，但是 reward 字段则无法利用到索引</strong>。</p>
<p>不使用索引下推时（mysql 5.6版本之前），执行器与存储引擎的执行流程如下：</p>
<blockquote>
<p>1、Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age &gt; 20 的第一条记录；</p>
<p>2、存储引擎根据二级索引的 B+ 树快速定位到这条记录后，获取主键值，然后进行回表操作，将完整的记录返回给 Server 层；</p>
<p>3、Server 层在判断该记录的 reward 是否等于 100000，如果成立则将其发送给客户端；否则跳过该记录；</p>
<p>4、接着，继续向存储引擎索要下一条记录，存储引擎在二级索引定位到记录后，获取主键值，然后回表操作，将完整的记录返回给 Server 层；</p>
<p>5、如此往复，直到存储引擎把表中的所有记录读完。</p>
<p>可以看到，没有索引下推的时候，每查询到一条二级索引记录，都要进行回表操作，然后将记录返回给 Server，接着 Server 再判断该记录的 reward 是否等于 100000。</p>
</blockquote>
<p>而使用索引下推后，判断记录的 reward 是否等于 100000 的工作交给了存储引擎层，过程如下 ：</p>
<blockquote>
<p>1、Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age &gt; 20 的第一条记录；</p>
<p>存储引擎定位到二级索引后，先不执行回表操作，而是先判断一下该索引中包含的列（reward列）的条件（reward 是否等于 100000）是否成立。如果条件不成立，则直接跳过该二级索引。如果成立，则执行回表操作，将完成记录返回给 Server 层。</p>
<p>3、Server 层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。</p>
<p>4、如此往复，直到存储引擎把表中的所有记录读完。</p>
<p>可以看到，使用了索引下推后，虽然 reward 列无法使用到联合索引，但是因为它包含在联合索引（age，reward）里，所以直接在存储引擎过滤出满足 reward &#x3D; 100000 的记录后，才去执行回表操作获取整个记录。相比于没有使用索引下推，节省了很多回表操作。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>执行一条 SQL 查询语句，期间发生了什么？</p>
<ul>
<li>连接器：建立连接，管理连接、校验用户身份；</li>
<li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li>
<li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li>
<li>执行 SQL：执行 SQL 共有三个阶段：<ul>
<li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li>
<li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li>
<li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法</title>
    <url>/sort-algorithm.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><img src="/sort-algorithm/sort.png" alt="sort_algorithm"></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>比较相邻元素，如果顺序不对就交换，每一轮都找到一个最大&#x2F;最小的数移动到末尾或开头</p>
<p>重复完成剩余的待排序元素</p>
<p>代码详解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> <span class="keyword">implements</span> <span class="title class_">IArraySort</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="comment">//拷贝原数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提前结束标志位</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提前结束</span></span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *交换数组中的两个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>遍历数组，从数组找到一个最小&#x2F;最大的数，放在开头或末尾</p>
<p>对剩余待排序数组重复以上操作直至数组有序</p>
<p>代码详解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> <span class="keyword">implements</span> <span class="title class_">IArraySort</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 寻找当前索引之后的最小值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果最小值不是当前值，则交换</span></span><br><span class="line">            <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">                swap(arr, i, minIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *交换数组中的两个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>将待排序的元素逐个插入到已经排序的序列中的合适位置，直到整个序列都排好序为止。</p>
<p>代码详解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span> <span class="keyword">implements</span> <span class="title class_">IArraySort</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="comment">// 插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j != i)&#123;</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p>
<p>代码详解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> <span class="keyword">implements</span> <span class="title class_">IArraySort</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        shellSort(sourceArray);</span><br><span class="line">        <span class="keyword">return</span> sourceArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] sourceArray)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sourceArray.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> sourceArray[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - gap;</span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; sourceArray[j] &gt; temp) &#123;</span><br><span class="line">                    sourceArray[j + gap] = sourceArray[j];</span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                sourceArray[j + gap] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            gap /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>将一个待排序的序列分成两个子序列，分别对两个子序列进行排序，然后将两个已排序的子序列合并成一个有序序列。</p>
<h3 id="递归版本"><a href="#递归版本" class="headerlink" title="递归版本"></a>递归版本</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> <span class="keyword">implements</span> <span class="title class_">IArraySort</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归归并排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] sourceArray, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(sourceArray, left, mid);</span><br><span class="line">        mergeSort(sourceArray, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(sourceArray, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并两个有序数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] sourceArray, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (a &lt;= mid &amp;&amp; b &lt;= right) &#123;</span><br><span class="line">            help[i++] = sourceArray[a] &lt;= sourceArray[b] ? sourceArray[a++] : sourceArray[b++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左侧指针、右侧指针，必有一个越界、另一个不越界</span></span><br><span class="line">        <span class="keyword">while</span> (a &lt;= mid) &#123;</span><br><span class="line">            help[i++] = sourceArray[a++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (b &lt;= right) &#123;</span><br><span class="line">            help[i++] = sourceArray[b++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            sourceArray[i] = help[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="非递归版本"><a href="#非递归版本" class="headerlink" title="非递归版本"></a>非递归版本</h3><p>待续……</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>选择一个基准元素，将数组分成两个子数组</p>
<p>使得左边元素都小于基准，右边元素都大于基准</p>
<p>对左右子数组递归地进行快速排序</p>
<p>代码详解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> <span class="keyword">implements</span> <span class="title class_">IArraySort</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        quickSort(sourceArray, <span class="number">0</span>, sourceArray.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sourceArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序（递归）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] sourceArray, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(sourceArray, left, right);</span><br><span class="line">            quickSort(sourceArray, left, pivot - <span class="number">1</span>);</span><br><span class="line">            quickSort(sourceArray, pivot + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分区（排序）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] sourceArray, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> sourceArray[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sourceArray[i] &lt; pivot) &#123;</span><br><span class="line">                swap(sourceArray, i, index);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(sourceArray, left, index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] sourceArray, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> sourceArray[a];</span><br><span class="line">        sourceArray[a] = sourceArray[b];</span><br><span class="line">        sourceArray[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>建立一个计数器辅助数组，大小为待排序数组中的最大值+1，统计原数组中每个元素 i 出现的次数，存入计数器数组中的第 i 项。</p>
<p>将计数器数组中大于0的元素反向填充到原数组中。</p>
<p>代码详解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计数排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountingSort</span> <span class="keyword">implements</span> <span class="title class_">IArraySort</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        countingSort(sourceArray);</span><br><span class="line">        <span class="keyword">return</span> sourceArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span>[] sourceArray)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> getMaxValue(sourceArray);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建计数数组</span></span><br><span class="line">        <span class="type">int</span>[] countArray = <span class="keyword">new</span> <span class="title class_">int</span>[maxValue + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 填充计数数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : sourceArray) &#123;</span><br><span class="line">            countArray[value]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 填充原数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; countArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (countArray[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sourceArray[index++] = i;</span><br><span class="line">                countArray[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数组中的最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">(<span class="type">int</span>[] sourceArray)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> sourceArray[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : sourceArray) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> HeapSort</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> xudu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span> 2026/1/4 21:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> <span class="keyword">implements</span> <span class="title class_">IArraySort</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            heapInsert(arr, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            swap(arr,<span class="number">0</span>, --size);</span><br><span class="line">            heapify1(arr,<span class="number">0</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i位置的数，向上调整大根堆</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; arr[i] &gt; arr[(i - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">            swap(arr, i, (i - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i位置的数，向下调整大根堆</span></span><br><span class="line">    <span class="comment">// 当前堆的大小为size</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapify1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; size) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">best</span> <span class="operator">=</span> l + <span class="number">1</span> &lt; size &amp;&amp; arr[l + <span class="number">1</span>] &gt; arr[l] ? l + <span class="number">1</span> : l;</span><br><span class="line">            best = arr[best] &gt; arr[i] ? best : i;</span><br><span class="line">            <span class="keyword">if</span> (best == i) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, best, i);</span><br><span class="line">            i = best;</span><br><span class="line">            l = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>待续……</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>待续……</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>sort</tag>
      </tags>
  </entry>
</search>
